Проблема N+1 селекта возникает в Hibernate, кода используется сущность со списком при использовании
любого типа аннотации (@OneToOne,  @OneToMany и т.п.)

Когда над списком сущностей стоит  fetch type EAGER

@OneToMany(fetch = FetchType.EAGER)

если достать списком все сущности то hibernate вытянет сначала список например пользователей
и для каждого пользователя вытащит N атрибутов отдельными запросами. поэтому проблема N+1.

------------------------------------------------------------------------------------------------------------------------
Что происходит при @OneToMany(fetch = FetchType.EAGER)
Допустим сущность Account имеет список счетов Bill

_______                                                 FetchType.EAGER
Account |----------                                   Select Account.....
-------           |-----Bill (1)                      Select Bill(1).....
                  |
                  |-----Bill (2)                      Select Bill(2).....
                  |
                  |-----Bill (3)                      Select Bill(3).....
                  |
                  ............                    .............................
                  ............                    .............................
                  |
                  ------Bill (N)                      Select Bill (N)....


FetchType.EAGER работает таким образом, что достает сущность и все её связи к другим сущностям
В таком случае если попробовать найти сущность Account (используя FetchType.EAGER) сначала произойдет
первый селект на сущность Account. И далее Hibernate произведет N седелектов для каждой сущности Bill
итого произойдет N селектов для Bill и 1 селект для Account. Таким образом количество обращений в базу данных будет
не рационально велико
-----------------------------------------------------------------------------------------------------------------------
Что происходит при @OneToMany(fetch = FetchType.LAZY)

_______                                                 FetchType.LAZY
Account |----------                                   Select Account.....
-------           |-----Bill (1)
                  |                                 ОСТАЛЬНЫХ СЕЛЕКТОВ НЕ ПРОИЗОЙДЕТ ПОТОМУ ЧТО ОБРАЩЕНИЙ
                  |-----Bill (2)                    К СЧЕТАМ Bill не было
                  |
                  |-----Bill (3)                    Обращение в базу данных будет только когда в работающем приложении
                  |                                 потребуются счета
                  ............
                  ............                      Например при вызове account.getBills();
                  |                                 В таком случае Hibernate выполнит один селект по выводу всех
                  ------Bill (N)                    счетов Bill.
                                                    ЭТО ОПТИМАЛЬНОЕ РЕШЕНИЕ, КОТОРОЕ СОКРАТИТ ВРЕМЯ РАБОТЫ ПО ПОЛУЧЕНИЮ
                                                    СУЩНОСТИ Account и счетов Bill. Нюанс заключается в том что получение
счета Bill в таком случае должно быть при открытой сессии. В противном случае возникнет ошибка (could not initialize proxy - no Session)

========================================================================================================================

Правила как избежать проблемы N+1
- Все поля делать Lazy кроме тех кто будет Eager. Кроме того, если будет 2 и более List Eager то получим
multibag Fetch exception - так как hibernate не сможет смаппить отдельные листы
________________________________
пусть будет пользователь User и количество книг у пользователя List<Book>
тогда
первый запрос вытащит список пользователей например 5 пользователей и для каждого пользователя вытащит
список книг where user.id = ? итого будет 6 запросов (1 + 5) один запрос на список пользователей
и для каждого пользователя список книг.
!!!--------------------------------
@BatchSize(size = 3)
первый вариант решения N + 1 получать аттрибуты батчем
для этого where user.id = ? нужно заменить where user.id in (?, ?, ?) где количество id это @BatchSize(size = 3)
если вытягивается список сущностей то для каждой сущности выполняется запрос, который заканчивается
тогда количество запросов сократиться до 1 + 5/3 -> 1 + 2 -> 3 это для 5 пользователей
если пользователей 100 то 1 + 100/3 --> 1 + 33 --> 34 запроса
таким образом частично решается N + 1 проблема

@BatchSize не работает с аннотацией @ManyToOne
в таком случае нужно ставить аннотацию над классом сущности

при использовании списка List<Book> необходимо ставить @BatchSize над полем списка.
в таком случае не будет работать аннотация установленная над классом сущности
@BatchSize позволяет использовать любые агрегирующие функции, так же limit и offset и т.п.
не будет декартовых произведений
!!!---------------------------------
@Fetch(FetchMode.SELECT)
используется для запросов getById(), для HQL и QueryDsl не работает. Отдельный подзапрос для каждой сущности поэтому
никакого выигрыша не даёт.

@Fetch(FetchMode.JOIN)
Join запрос используется для отдельной сущности или коллекции для запросов getById(), для HQL и QueryDsl не работает!!!

@Fetch(FetchMode.SUBSELECT)
сначала вытаскиваются все пользователи, потом для каждого аттрибута выполнится запрос следующего вида
Select * from Book where user.id in (select user.id from user where user.name like %___a%)
Для коллекций работает как @BatchSize отличие в том что id получаются подзапросом in по указанному количеству size
в @Fetch(FetchMode.SUBSELECT) количество user.id in (количество определяется подзапросом), работает только для HQL, QueryDsl
не работает для getById();

поэтому не покрывает все возможные случаи, иногда необходимо получить аттрибуты вместе с пользователем

