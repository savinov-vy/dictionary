Проблема N+1 селекта возникает в Hibernate, кода используется сущность со списком при использовании
любого типа аннотации (@OneToOne,  @OneToMany и т.п.)

Когда над списком сущностей стоит  fetch type EAGER

@OneToMany(fetch = FetchType.EAGER)

если достать списком все сущности то hibernate вытянет сначала список например пользователей
и для каждого пользователя вытащит N атрибутов отдельными запросами. поэтому проблема N+1.

------------------------------------------------------------------------------------------------------------------------
Что происходит при @OneToMany(fetch = FetchType.EAGER)
Допустим сущность Account имеет список счетов Bill

_______                                                 FetchType.EAGER
Account |----------                                   Select Account.....
-------           |-----Bill (1)                      Select Bill(1).....
                  |
                  |-----Bill (2)                      Select Bill(2).....
                  |
                  |-----Bill (3)                      Select Bill(3).....
                  |
                  ............                    .............................
                  ............                    .............................
                  |
                  ------Bill (N)                      Select Bill (N)....


FetchType.EAGER работает таким образом, что достает сущность и все её связи к другим сущностям
В таком случае если попробовать найти сущность Account (используя FetchType.EAGER) сначала произойдет
первый селект на сущность Account. И далее Hibernate произведет N седелектов для каждой сущности Bill
итого произойдет N селектов для Bill и 1 селект для Account. Таким образом количество обращений в базу данных будет
не рационально велико
-----------------------------------------------------------------------------------------------------------------------
Что происходит при @OneToMany(fetch = FetchType.LAZY)

_______                                                 FetchType.LAZY
Account |----------                                   Select Account.....
-------           |-----Bill (1)
                  |                                 ОСТАЛЬНЫХ СЕЛЕКТОВ НЕ ПРОИЗОЙДЕТ ПОТОМУ ЧТО ОБРАЩЕНИЙ
                  |-----Bill (2)                    К СЧЕТАМ Bill не было
                  |
                  |-----Bill (3)                    Обращение в базу данных будет только когда в работающем приложении
                  |                                 потребуются счета
                  ............
                  ............                      Например при вызове account.getBills();
                  |                                 В таком случае Hibernate выполнит один селект по выводу всех
                  ------Bill (N)                    счетов Bill.
                                                    ЭТО ОПТИМАЛЬНОЕ РЕШЕНИЕ, КОТОРОЕ СОКРАТИТ ВРЕМЯ РАБОТЫ ПО ПОЛУЧЕНИЮ
                                                    СУЩНОСТИ Account и счетов Bill. Нюанс заключается в том что получение
счета Bill в таком случае должно быть при открытой сессии. В противном случае возникнет ошибка (could not initialize proxy - no Session)

========================================================================================================================

Правила как избежать проблемы N+1
- Все поля делать Lazy кроме тех кто будет Eager. Кроме того, если будет 2 и более List Eager то получим
multibag Fetch exception - так как hibernate не сможет смаппить отдельные листы
________________________________
пусть будет пользователь User и количество книг у пользователя List<Book>
тогда
первый запрос вытащит список пользователей например 5 пользователей и для каждого пользователя вытащит
список книг where user.id = ? итого будет 6 запросов (1 + 5) один запрос на список пользователей
и для каждого пользователя список книг.
!!!--------------------------------
@BatchSize(size = 3)
первый вариант решения N + 1 получать аттрибуты батчем
для этого where user.id = ? нужно заменить where user.id in (?, ?, ?) где количество id это @BatchSize(size = 3)
если вытягивается список сущностей то для каждой сущности выполняется запрос, который заканчивается
тогда количество запросов сократиться до 1 + 5/3 -> 1 + 2 -> 3 это для 5 пользователей
если пользователей 100 то 1 + 100/3 --> 1 + 33 --> 34 запроса
таким образом частично решается N + 1 проблема

@BatchSize не работает с аннотацией @ManyToOne
в таком случае нужно ставить аннотацию над классом сущности

при использовании списка List<Book> необходимо ставить @BatchSize над полем списка.
в таком случае не будет работать аннотация установленная над классом сущности
@BatchSize позволяет использовать любые агрегирующие функции, так же limit и offset и т.п.
не будет декартовых произведений
!!!---------------------------------
@Fetch(FetchMode.SELECT)
используется для запросов getById(), для HQL и QueryDsl не работает. Отдельный подзапрос для каждой сущности поэтому
никакого выигрыша не даёт.

@Fetch(FetchMode.JOIN)
Join запрос используется для отдельной сущности или коллекции для запросов getById(), для HQL и QueryDsl не работает!!!

@Fetch(FetchMode.SUBSELECT)
сначала вытаскиваются все пользователи, потом для каждого аттрибута выполнится запрос следующего вида
Select * from Book where user.id in (select user.id from user where user.name like %___a%)
Для коллекций работает как @BatchSize отличие в том что id получаются подзапросом in по указанному количеству size
в @Fetch(FetchMode.SUBSELECT) количество user.id in (количество определяется подзапросом), работает только для HQL, QueryDsl
не работает для getById();

поэтому не покрывает все возможные случаи, иногда необходимо получить аттрибуты вместе с пользователем

!!!---------------------------------
Более часто используемый способ это использование слова fetch прямо в HQL запросе
"select u from User u join fetch u.books where u.name like %___a%
в таком случае будет вытянуто намного больше строк, т.к. в результирующем наборе кроме всех полей пользователя будут
вытянуты все поля из листа книг. И будет декартово произведение между листом полей книг и если у пользователя
будет ещё поле-сущность например home то перемножатся все поля сущности Home с полями сущности Book
не будет критично перемножение одной сущности с листом сущностей, но будет уже критичнее переменожение множеств
полей одного листа с полями другого листа. Т.к. строк будет много то limit offset и аггрегирующие функции не будут
работать.
в некоторых случаях можно сделать выбор в пользу FetchMode.SUBSELECT

если выполнить без fetch
"select u from User u join u.books where u.book.name like %___a%
то в результирующий набор не попадут поля из book и по производительности такой запрос будет гораздо выше

использование fetch в HQL позволяет использовать limit offset и агрегирующие функции.
fetch только добавляет колонки из таблиц в результирующий набор.
В случае работы с одной сущностью getById(), когда все поля будут помечены FetchType.LAZY для полей будут вытаскиваться

-------------------------------------------
@FetchProfile вытянуть отдельные поля @ManyToOne или коллекции @ManyToMany с использованием getById() для HQL
и QueryDsl работать не будет
-------------------------------------------
@EntityGraphs можно использовать по аналогии с eclipse link
работает и для getById и в HQL
создаются subGraphs и NamedEntityGraph с аттрибутами,к которые нужно вытянуть .
аннотациями пользоваться очень объемно поэтому можно пользоваться программно
var userGraph = session.createEntityGraph(User.class); <- создать графф
userGraph.addAttributeNodes("company", "userChats"); <- добавить вытягиваемые поля и сабграфы которые нужно вытянуть
var userChatsSubgraph = userGraph.addSubgraph("userChats", UserChat.class) <- создать сабграф и имя "userChats"
userChatsSubgraph.addAttributeNodes("chat"); <- добавить в сабграф вытягиваемые поля

теперь передаём в запросы
Map<String, Object> properties = Map.of(GraphSemantic.LOAD.getJpaHintName(), userGraph);

var user = session.find(User.class, 1L, properties); <-- getById() работать не будет только findById()

var users = session.createQuery("select u from User u " + "where 1 = 1", User.class)
            .setHint(GraphSemantic.LOAD.getJpaHintName(), userGraph)
            .list();